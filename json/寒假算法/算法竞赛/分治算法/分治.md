## 分治
---
![清华大学](https://img.imgdb.cn/item/600ab3393ffa7d37b32e74e2.jpg)
---
#### 什么是分治？
分治，顾名思义就是分而治之。遇到一些较大规模的问题时，我们就可以尝试将这个问题分成较小规模的相似问题来解决。

下面举一个简单的例子来说明问题：

>有20个已经从小到大排序好的数据，输入一个数X，判断它是否在这20个数中

很简单的思想就是写一个for循环，里面来一个if判断，从第一个数判断到第二十个数，如果有，则可以直接输出true，否则输出false。用代码实现的话就是
``` cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int a[20] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    int num = 0;
    cin >> num;
    for (int  i = 0; i < 20; ++i)
    {
        if (a[i] == num)
        {
            printf("true");
            exit(0);
        }
    }
    cout << "false" << endl;
    return 0;
}
```
这样的算法看起来简单易读，但是有一个致命的缺陷，就是时间复杂度。如果仅仅是20个数字，程序很轻松的就算出来了。但如果是1000000000个数字呢？这样线性查找的时间复杂度是O(N)，显然当N足够大的时候，我们的程序就会超时，这是我们不愿意看到的。

那么有什么方法可以降低时间复杂度呢？这时候分治的思想就体现出来了，我们可以将这20个数，mid=10；然后去判断mid和num的大小关系，如果num\< mid那么就证明num在mid左边，那么我们只需要看前10个数就可以了。

这样下来，大大减少了程序的时间复杂度，如果一共有N个数，第一次查找剩下n/2个数，第二次n/4个数，第三次n/8个数……么这样下来，我们就可以得出一个公式：如果我们脸黑到极致，最后一次才找到我们要找的那个数，设一共找了x次，
$$n*(\frac{1}{2})^x=1$$
那么
$$2^x=n$$

$$log_2(n)=x$$
所以二分查找的时间复杂度就是O($log(n)$)
这样，时间复杂度就大大的降低了

**我们好像忘了一些什么。这个算法实现的依据基本要点是什么？**

回过头来看，这20个数是从小到大排好的，这就是使用二分的前提。if里面判断的就是mid和num的大小关系，从而可以进行下一步的操作，如果说这是个无序数列的话，又何谈前半段还是后半段呢？

---
