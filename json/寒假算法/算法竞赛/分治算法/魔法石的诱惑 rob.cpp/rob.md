## 寒假算法记录 ##
---
![th.jpg](https://www.tsinghua.edu.cn/images/20/04/29/263mcc6ojy/qinghualu.jpg)
---
### 魔法石的诱惑 rob.cpp
#### 题目描述：
> 修罗王远远地看见邪狼狂奔而来，问道：“慌慌张张地跑什么？” 邪狼大口大口地喘气：“我路过一家魔法石店，看到摆着那么多高阶魔法石，我就跑进去抢了一大袋。” 修罗王怒道：“光天化日，朗朗乾坤，众目睽睽之下，你也敢抢？” 邪狼：“我抢魔法石的时候，压根儿就没看见人，眼里只看见魔法石了。” 修罗王：“……” 其实邪狼的贪婪很容易理解，因为高阶魔法石有一个特征，即它的重量进行阶乘运算后末尾有几个0，就拥有同等重量普通魔法石几倍的魔法力。例如5!=5×4×3×2×1=120，而120结尾包含1个零，这意味着该魔法石拥有同等重量的普通的魔法石1倍的魔法力。你的任务是找到最小自然数N，使N!在十进制下包含Q个零。
#### 输入格式：
> 一个数Q（0≤Q≤10⁸）
#### 输出格式：
> 如果误解，输出“No solution”，否则输出N。
#### 样例输入：
> 2
#### 样例输出：
> 10
---
#### _题目分析_：
- 要点
  1. 题目的核心就是找到一个最小的数N，使N！得出的结果后有Q个零，而这个Q就是我们要输入的那个值。
  2. 如何确定N！后有几个零？
     1. 首先，我们要知道，一个数后面的0是怎么来的。众所周知，一个数字后面想多一个0就需要把它乘上一个10，那么这个数末尾就多一个0。
     2. 那么接下来，我们只需要知道这个n！中到底乘了多少个10就可以了。但它不是简单的找到从1~n中有几个0的问题，因为10还有两个因数2和5，那么问题就变成了找到1~n中有多少个2和多少个5的问题。
     3. 我们知道，在1~9中，能提供2的数有，2、4、6、8，能提供5的数只有5。那么看来2是不缺的，那么问题进一步转化为要问n！后面有多少0，就是问n！中有多少个5.
     4. 这样就很简单了：
        - 每隔5个数，就会出现一个5.例如：5、10、15、20……
        - 每隔5*5个数，就会多出现一个5.例如：25、50、75……
        - 每隔5\*5*5个数，就会再多出现一个5.例如：125……
  3. 由于数据很大，所以采用二分法来找。
---
``` cpp
#include<iostream>
#include<cstdio>
using namespace std;

int solve(int n)
{
    int ans = 0;
    while (n>0)
    {
        ans += n / 5;//判断有几个5
        n = n / 5;
    }
    return ans;
}

int main()
{
    int Q;
    scanf("%d", &Q);
    int start = 1;
    int end = 500000000;
    int ans = 500000001;
    int mid;
    int t;
    while(start<=end){
        mid = start + (end - start) / 2;//防止溢出
        t = solve(mid);
        if (t == Q && mid < ans){ //这里的二分有些许不同，因为要找的是最小的，
           //所以要不断地找，找到最小的合适的数字
            ans = mid;
        }
        if (t > Q){
            end = mid - 1;
        }
        else if (t < Q){
            start = mid + 1;
        }
        else{
            end = mid - 1;
        }
    }
    if(ans != 500000001){
        printf("%d", ans);
    }
    else{
        cout << "No solution." << endl;
    }
    return 0;
}
```
---
参考文献：

[N!后面的0的位数]:https://blog.csdn.net/ee8736199/article/details/48105017/
[N!后面的0的位数];